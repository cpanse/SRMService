---
title: "FGCZ Two-Group Analysis: `r params$grp$projectName` \n Statistics for a Quantitative Phospho Peptides Matrix"
author: "Functional Genomics Center Zurich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: default
  html_document: default
params:
  grp: !r quote(SRMService::genericQuantMatrixGRP2)
vignette: >
  %\VignetteIndexEntry{FGCZ Two-Group Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes: |
    \usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhead[CO,CE]{Group Comparison}
    \fancyfoot[CO,CE]{Functional Genomics Center Zurich - 2018}
    \fancyfoot[LE,RO]{\thepage} 
bibliography: bibliography.bib

---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

if(!exists("progress")){
  progress <- function(howmuch, detail){
    invisible(NULL)
  }
}

grp2 <- eval(params$grp)

library(tidyverse)
library(knitr)
library(limma)
library(kableExtra)
library(dplyr)
library(reshape2)
library(quantable)
library(ggplot2)
library(dplyr)

```

# Introduction

The following analysis compares individual phospho peptide signal intensities recorded in multiple samples from (usually) two conditions (Tables \@ref(tab:samples) and \@ref(tab:annotation)) by computing the fold change $log2(condition/reference)$, and by testing if this fold change (also later called effect size) is different from zero. Table \@ref(tab:groupingvars) shows the group used as the reference.


The peptide identification and quantification were performed using the _MaxQuant_ software and _Andromeda_ search engine [@Cox2008, Cox2011].  Here we are starting with the `Phospho STY Sites.txt`  file generated by MaxQuant; we run a set of functions implemented in the R package SRMService [@SRMService2018] to generate visualization and to compute a _moderated t-test_ [@Smyth2004] for all phospho peptides reported in the `Phospho STY Sites.txt`  file if they have enough evidence with respect to signal intensities in multiple experiments (rows are filtered out if they have too many NAs). For the statistical testing we are employing the R package limma [@Ritchie2015a].

For questions and improvements, please do contact <protinf@fgcz.uzh.ch>.



## Experiment summary

Experiment is called: `r grp2$projectName`

The phospho peptide matrix is filtered like this:

- Maximum of missing values per phospho peptide : `r grp2$maxNA`


- Total number of different phospho peptides in this experiment is: `r nrow(grp2$proteinIntensity)` 
- Total number without decoys sequences is `r nrow(grp2$proteinIntensity) -  sum(grepl("REV__",grp2$proteinAnnotation$ProteinName))` 


- Percentage of contaminants : `r round(mean(grepl("CON__",grp2$proteinAnnotation$ProteinName)) * 100, digits=1)` %
- Percentage of false postivies : `r round(mean(grepl("REV__",grp2$proteinAnnotation$ProteinName)) * 100, digits=1)` %



```{r samples}
tab <- data.frame(table(grp2$getAnnotation()$Condition))
colnames(tab) <- c("Condition","# samples")
knitr::kable(tab, "latex", caption="Nr of samples in each condition.")

```

Here the files in each group:

```{r annotation}
tab <- grp2$getAnnotation()[,c("Condition","Raw.file")]
rownames(tab) <- NULL
knitr::kable(tab, "latex", caption="Condition sample mapping.")

```

```{r groupingvars}
x <- data.frame(name = unlist(grp2$getConditions()))
knitr::kable(x, "latex", caption="The reference group is in the denominator of the foldchnages.")
```


\pagebreak

## The Phospho Peptide Quantities


```{r histmissing }
missing <- grp2$getNrNAs()
int <- apply(grp2$proteinIntensity,1,sum, na.rm=TRUE)
grp2$proteinIntensity <- grp2$proteinIntensity[order(missing, -int,decreasing = T),]
```

The input matrix has the following structure (Figure \@ref(fig:overview)).

```{r overview, fig.width=8,fig.height=7,dpi=300,fig.cap="Heatmap for quantifyable phospho peptides sorted by missigness and intensity (log2). Gray - missing values"}
imageWithLabels(t(log2(grp2$proteinIntensity)), col.labels = NULL, col=quantable::getBlueScale(21))
```



```{r missingValuesPerProtein, fig.cap="# of missing values per phospho peptides", fig.height=3,fig.width=5}
barplot(table(missing), xlab="number of missing values", ylab="number of phospho peptides")
progress(0.1, "Summary")
```


```{r ggHistMissing, fig.cap="# of missing values with respect to mean intensity", fig.height=3,fig.width=5}
intMean <- apply(grp2$proteinIntensity,1,mean, na.rm=TRUE)
myDat <- data.frame(meanExpression=log2(intMean),nrNA= as.factor(grp2$getNrNAs()))
#ggplot(myDat, aes(x=myDat$meanExpression, fill=myDat$nrNA)) + geom_histogram(alpha=0.2, position="identity")
gghist <- ggplot(myDat, aes(x=meanExpression, fill=nrNA, colour=nrNA)) + geom_histogram(alpha=0.2, position="identity")
gghist
```


\pagebreak

# Quality Control

## Distribution of Intensities

Shown in Figure \@ref(fig:distributionRaw) are the distributions of raw log2 transformed intensity values. Ideally the violins should look very similar.

```{r distributionRaw, fig.width=8, fig.height=5, fig.cap="Violin plots for quantifyable phospho peptides (log2 transformed)"}
longm <- melt(log2(grp2$proteinIntensity))

p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="log2(I)")
p + stat_summary(fun.y=median,geom='point') +theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()

```

In Figure \@ref(fig:scaling) the log2 fold change of the average sample intensity versus the mean average intensity of all samples is shown. It is critical if a samples average deviates more than 5 times from the average of all samples.

```{r  scaling,dpi=300, fig.height=6, fig.cap="Average intensity in sample vs average intensity in all samples. red line - critical fold change."}
bb <- grp2$getNormalized()$medians

par(mar=c(15,6,3,6))
barplot(sort(abs(bb))  - mean(bb) ,horiz=F,las=2, main="median", cex.names = 0.6, ylab="log2(sample average) - log2(total average)", ylim=c(-log2(8),log2(8)))
abline(h=c(-log2(5),log2(5)),col=2)
x<-seq(-3,3,by=1)
axis(4,x,round(2^abs(x),digits=1))
mtext("linear scale", side=4, line=2)
```

```{r progress2}
progress(0.2, "Normalization")
```

## Normalization

Figure \@ref(fig:normalized) shows the normalized values. Normalization is applied to remove systematic differences in phospho peptide abundance due to different sample concentrations, so that differentially expressed phospho peptides can be detected. To do this the z-score of the log2 transformed intensities are computed, which in addition is multiplied by the average of the standard deviation of the log2 transformed intensities in all samples. After normalization all samples have a similar distribution.


```{r normalized,  fig.width=8,fig.height=5,dpi=300, fig.cap="Violin plots of normalized phospho peptide intensity values (z-score)"}
longm <- melt(grp2$getNormalized()$data)
p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="z-score")
p + stat_summary(fun.y=median, geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + coord_flip()
```

\pagebreak


The Figure \@ref(fig:SDViolin) left panel, show the coefficient of variations for all phospho peptides in each condition and overall computed on not normalized data. To observe differences between conditions the variation within a condition should ideally be smaller than within all conditions.


```{r CViolin}
cond1 <- grp2$getConditionData(grp2$conditions[1])
cond2 <- grp2$getConditionData(grp2$conditions[2])

cond1 <- quantable::CV(cond1,top= round(nrow(grp2$proteinIntensity)/20))
cond2 <- quantable::CV(cond2,top= round(nrow(grp2$proteinIntensity)/20))

all <- quantable::CV(grp2$proteinIntensity,top= round(nrow(grp2$proteinIntensity)/20))

arethereCVS <-(length(cond1) > 0 & length(cond2) > 0) & length(all) >0
if( arethereCVS)
{
  CVs <- rbind(data.frame(condition=grp2$conditions[1], cv=cond1),
               data.frame(condition=grp2$conditions[2],cv=cond2 ),
               data.frame(condition="all", cv=all))
  p <- qplot( condition , cv , data=CVs , geom="violin" , xlab="" , ylab="Coefficient of Variation (%)")
  p1 <- p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))
}

```


```{r}
if(arethereCVS){
  cvSummary <- aggregate(cv ~ condition , data=CVs , median, na.rm=TRUE)
  knitr::kable(cvSummary, "latex",caption = 'median of cv')
}
```

The Figure \@ref(fig:SDViolin) shows the distributions of standard deviations for all phospho peptides with the conditions and overall after transforming and normalization the data. To observe differences between conditions the standard deviation within a condition should be smaller than across all conditions.  

```{r SDViolin, fig.height=3, fig.width=7, fig.cap="Left panel - Distribution of phospho peptide CV within condition and overall, Right panel - Distribution of phospho peptides standard deviation (after sample normalization and scaling) within conditions and overall"}

cond1 <- grp2$getNormalizedConditionData( grp2$conditions[1] )
cond2 <- grp2$getNormalizedConditionData( grp2$conditions[2] )

cond1 <- apply(cond1, 1, sd, na.rm=TRUE)
cond2 <- apply(cond2, 1, sd, na.rm=TRUE)

all <- apply( grp2$getNormalized()$data, 1 , sd, na.rm=TRUE )
SDs<-rbind(data.frame( condition=grp2$conditions[1], sd=cond1), data.frame(condition=grp2$conditions[2],sd=cond2 ), data.frame(condition="all", sd=all))

p2 <- qplot( condition , sd , data=SDs , geom="violin" , xlab="" , ylab="sd of z-score")
p2 <- p2 + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

gridExtra::grid.arrange(p1,p2, nrow=1)
```

```{r}
sdSummary <-aggregate(sd ~ condition , data=SDs , median, na.rm=TRUE)
knitr::kable(sdSummary, "latex", caption = 'median of sd')

progress(0.1, "CVs")

```

\pagebreak

## Clustering for Samples and Phospho Peptides

```{r correlation, dpi=300, fig.height=5, fig.width=7, fig.cap="Heatmap of correlations (spearman) between samples."}
col <- c("red","blue")
simpleheatmap(cor(grp2$getNormalized()$data, 
                  use="pairwise.complete.obs", 
                  method="spearman")^2,
              palette = getGreensScale(21),
              RowSideColors = col[as.factor(grp2$getAnnotation()$Condition)], 
              margins = c(1,15), labRow =colnames(grp2$getNormalized()$data), labCol="", dendrogram="row" )
```

In Figure \@ref(fig:correlation) and Figure \@ref(fig:heatmapData) we show how samples are clustered depending on their correlation and on the phospho peptide expression profiles.


```{r heatmapData, fig.width=8, fig.height=5, dpi=300, fig.cap="Heatmap of normalized data."}
tmp <- grp2$getNormalized()$data
stmMm <- grp2$getNormalized()$data[grp2$getNrNAs() < ncol(grp2$getNormalized()$data)/2,]
simpleheatmap((scale(t(stmMm),scale = F)),RowSideColors = col[as.factor(grp2$getAnnotation()$Condition)], margins=c(1,13),
              breaks=seq(-2.5,2.5,length=26),
              palette = getBlueWhiteRed(25),
              labCol="", labRow=colnames(stmMm), dendrogram="row")
progress(0.2, "Heatmaps")

```

\pagebreak


# Two Group Analysis

In the following analysis we assume that most of the phospho peptides are not regulated (fold change is equal zero). P-values and q-values are a measure of how likely it is to observe the data given the assumption that they are not differentially regulated. Small p-values tell us that $H_0$ (no regulation) is very unlikely. Figure \@ref(fig:densityOFFoldChanges) shows the distribution of fold changes. Most of the fold changes should be close to zero and also the median of all fold changes (red dashed line) should be close to zero (green line).





```{r}
fcname <- paste("log2(", grp2$getConditions()$condition, "/", grp2$getConditions()$reference, ")", sep="")
#res.eb <-grp2$getPValues()
#res.eb <-grp2$getModPValuesCI()
res.eb <-grp2$getModPValuesCI()
```


```{r densityOFFoldChanges, fig.width=8, fig.height=4, dpi=300, fig.cap = "Left panel : Distribution of log2(FC). red dashed line - median fold change. Right panel - Histogram of moderated p values."}
par(mfrow=c(1,2))
plot(density(na.omit(res.eb$log2FC)), main="")
abline(v=0,col="green")
abline(v=median(res.eb$log2FC),col=2,lty=2)
hist(res.eb$P.Value, breaks=20, xlab="moderated p-Value", main="")
abline(h=length(res.eb$P.Value)/20,col="blue")

```

\newpage

## Adjusted moderated p-values

If the groups are different we would expect more small p-values than by chance (Figure \@ref(fig:densityOFFoldChanges) right panel blue horizontal line). If there are only as many or less small p-values as by chance than no significant false discovery rate controlled calls (q-Values) will be made in Figure \@ref(fig:volcanoplot). Significant calls are made with q-value smaller than `r grp2$qvalue` (see Figure \@ref(fig:volcanoplot)). Table \@ref(tab:nrsignificant) summarizes the number of significant calls  while \@ref(tab:top20table) lists the phospho peptides with the smallest moderated q-values.


```{r volcanoplot, fig.width=10, fig.height=8, dpi=300, fig.cap= "q-value VolcanoPlot: x axis log2 fold change of normalized data, y axis -log10(Q-value)."}
res.eb$names <- rownames(res.eb)

p <- quantable::volcano2GB(res.eb,pvalue = "adj.P.Val", foldchange = "log2FC", 
                           ylab="-log10(Q Value)",
                           log2FCThresh=grp2$qfoldchange,
                           pthresh=grp2$qvalue)

if(length(grp2$special)>0)
{
  quantable::addSpecialProteins(p, res.eb, grp2$special)
}else{
  p
}

```


```{r volcanoplotpValues, fig.width=10, fig.height=8, dpi=300, fig.cap= "p-value VolcanoPlot: x axis log2 fold change of normalized data, y axis -log10(p-values)."}
res.eb$names <- rownames(res.eb)

p <- quantable::volcano2GB(res.eb, pvalue = "adj.P.Val", foldchange = "log2FC",
                           ylab="-log10(p-value)",
                           log2FCThresh=grp2$qfoldchange,
                           pthresh=grp2$qvalue)

if(length(grp2$special)>0)
{
  quantable::addSpecialProteins(p, res.eb, grp2$special,  pvalue = "adj.P.Val")
}else{
  p
}

```

\newpage


```{r nrsignificant, results="markup"}
tmp <- grp2$getResultTable()
x <- data.frame(table(abs(tmp$log2FC) > grp2$qfoldchange & tmp$adj.P.Val < grp2$qvalue))
if(length(x$Var1) == 2){
  x$Var1 <- c("Not Significant" , "Significant")
}
knitr::kable(x, "latex", caption = "Number of not significant and significant phospho peptides")
```



```{r top20table, size = 'tiny'}
top20 <- tmp %>% dplyr::select( TopProteinName,log2FC, adj.P.Val ) %>% arrange((adj.P.Val) ) %>% head(20)
knitr::kable(top20, "latex", caption = "Top 20 phospho peptides sorted by smallest Q Value (q.mod). The effectSize column is the log2 FC of condition - reference.") %>%
  kable_styling(font_size = 5)
```


\newpage


```{r presentInOnlyOneCondition}
results <- grp2$getResultTable()
NAinfo <- c(sum(is.na(results[, grp2$getConditions()$reference])) , 
            sum(is.na(results[, grp2$getConditions()$condition])) )
NAinfo<-data.frame(name = unlist(grp2$getConditions()), nrProteins= NAinfo)

child_docs <- "Grp2Analysis_MissingInOneCondtion.Rmd_t"
if(!sum(NAinfo$nrProteins > 0) > 0){
  child_docs <- "Grp2Analysis_Empty.Rmd_t"
}

child_docs <- system.file(file.path("ParametrizedReportsChild",child_docs),package = "SRMService")

```


## Data interpretation

For interpreting the results in more detail, please refer to the  _csv-files_ provided with this report, the phospho peptide IDs can be either sorted by `log2FC` or `adj.P.Value` (See Table \@ref(tab:columnlist)). Large positive or negative fold changes typically result in small p-values.
The sorted IDs can then be subjected to over-representation analysis (ORA) or gene set enrichment analysis (GSEA). The web application WebGestalt (WEB-based GEne SeT AnaLysis Toolkit) <http://www.webgestalt.org> implements both of these methods (and many more) for the most popular organisms [@Wang2017].

A further resource to analyze the results is the STRING database <https://string-db.org> [@Szklarczyk2017]. It reports known interactions for the proteins in the subset of proteins generated on a p-value or fold change threshold.

For the correct interpretation of the top hits, it is essential to specify the background proteome, this is the list of all proteins identified in your experiment.

The FGCZ can support you with the interpretation of your quantitative proteomics data or more sophisticated analysis on request. You can reach the bioinformatics coach of your project using the comment function in your bfabric project. If you have other ideas or improvements to this report, you may also write an email to protinf@fgcz.uzh.ch instead.

\newpage

```{r columnlist}
knitr::kable(data.frame(columns=colnames(grp2$getResultTableWithPseudo())), "latex", caption="List of column names in result .csv table.")
```


# Disclaimer

This document was generated using Rmarkdown and processes text files which are generated with a label-free quantitation software such as MaxQuant or Progenesis. 
The obtained results should be validated orthogonal as well (e.g. with Western blots). The Functional Genomics Center Zurich does not provide any kind of guarantee of the validity of these results.


# Session Info

```{r}
pander::pander(sessionInfo())
```


# References


